## Brief theories of everthing. 

## Notes: 
# "user" in this context refers to a logged-in, validated user. reference to an anonymous, public user will be explicit. 

                        ## See version below. 
ActiveRecord::Schema.define(version: 20150430133541) do

  create_table "bookmarks", force: :cascade do |t|
    t.integer  "user_id",                    null: false
    t.integer  "work_id",                    null: false
    # bookmarked:true means the bookmark "exists", "false" does not exist. for the scope of user-interaciton (UI), only bookmarks :true exist.
    # another way to manage bookmarks would be to delete them on un-bookmarking. i opted for the boolean for esoteric history's sake. 
    t.boolean  "bookmarked", default: false, null: false
    t.datetime "created_at",                 null: false
    t.datetime "updated_at",                 null: false
  end

  # bookmarks only exist for users so priority given to user matching, then work matching
  add_index "bookmarks", ["user_id", "work_id"], name: "index_bookmarks_on_user_id_and_work_id", unique: true
  # made obsolete by above index??? 
  add_index "bookmarks", ["user_id"], name: "index_bookmarks_on_user_id"
  # this index used to count number of bookmarks per work, which is done on each new bookmarking or un-bookmarking
  add_index "bookmarks", ["work_id"], name: "index_bookmarks_on_work_id"

  create_table "comments", force: :cascade do |t|
    t.integer  "user_id",    null: false
    t.integer  "work_id",    null: false
    # anti-comments not allowed
    t.text     "body",       null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  add_index "comments", ["user_id"], name: "index_comments_on_user_id"
  add_index "comments", ["work_id", "user_id"], name: "index_comments_on_work_id_and_user_id"
  add_index "comments", ["work_id"], name: "index_comments_on_work_id"

  # Table generated by the gem 'friendly_id' (https://github.com/norman/friendly_id). 
  # In use for works, schools, and users. 
  create_table "friendly_id_slugs", force: :cascade do |t|
    t.string   "slug",                      null: false
    t.integer  "sluggable_id",              null: false
    t.string   "sluggable_type", limit: 50
    t.string   "scope"
    t.datetime "created_at"
  end

  add_index "friendly_id_slugs", ["slug", "sluggable_type", "scope"], name: "index_friendly_id_slugs_on_slug_and_sluggable_type_and_scope", unique: true
  add_index "friendly_id_slugs", ["slug", "sluggable_type"], name: "index_friendly_id_slugs_on_slug_and_sluggable_type"
  add_index "friendly_id_slugs", ["sluggable_id"], name: "index_friendly_id_slugs_on_sluggable_id"
  add_index "friendly_id_slugs", ["sluggable_type"], name: "index_friendly_id_slugs_on_sluggable_type"


  create_table "gradients", force: :cascade do |t|
    # the actual 'grade'; currently [0..255] 
    t.integer  "grad",       null: false
    t.integer  "user_id",    null: false
    t.integer  "work_id",    null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  add_index "gradients", ["user_id", "work_id"], name: "index_gradients_on_user_id_and_work_id", unique: true
  add_index "gradients", ["user_id"], name: "index_gradients_on_user_id"
  add_index "gradients", ["work_id"], name: "index_gradients_on_work_id"

  # Table generated by gem 'impressionist' (https://github.com/charlotte-ruby/impressionist)
  # currently in use for users, works at #show (tallies when a work or user is viewed)
  create_table "impressions", force: :cascade do |t|
    t.string   "impressionable_type"
    t.integer  "impressionable_id"
    t.integer  "user_id"
    t.string   "controller_name"
    t.string   "action_name"
    t.string   "view_name"
    t.string   "request_hash"
    t.string   "ip_address"
    t.string   "session_hash"
    t.text     "message"
    t.text     "referrer"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  add_index "impressions", ["controller_name", "action_name", "ip_address"], name: "controlleraction_ip_index"
  add_index "impressions", ["controller_name", "action_name", "request_hash"], name: "controlleraction_request_index"
  add_index "impressions", ["controller_name", "action_name", "session_hash"], name: "controlleraction_session_index"
  add_index "impressions", ["impressionable_type", "impressionable_id", "ip_address"], name: "poly_ip_index"
  add_index "impressions", ["impressionable_type", "impressionable_id", "request_hash"], name: "poly_request_index"
  add_index "impressions", ["impressionable_type", "impressionable_id", "session_hash"], name: "poly_session_index"
  add_index "impressions", ["impressionable_type", "message", "impressionable_id"], name: "impressionable_type_message_index"
  add_index "impressions", ["user_id"], name: "index_impressions_on_user_id"

  # Table populated with data from http://ope.ed.gov/accreditation/GetDownLoadFile.aspx Excel file for 12/2014
  # I have whittled it down via approximately the following:
  ## remove all rows with populated Campus_ information; then removed those columns
  ## remove all rows with accreditation_status != :accredited
  ## remove all rows without an internet address
  create_table "schools", force: :cascade do |t|
    t.integer  "Institution_ID"
    t.string   "Institution_Name"
    t.string   "Institution_Address"
    t.string   "Institution_City"
    t.string   "Institution_State"
    t.string   "Institution_Zip"
    t.string   "Institution_Phone"
    t.string   "Institution_OPEID"
    t.string   "Institution_IPEDS_UnitID"
    t.string   "Institution_Web_Address"
    t.string   "Accreditation_Type"
    t.string   "Agency_Name"
    t.string   "Agency_Status"
    t.string   "Program_Name"
    t.string   "Accreditation_Status"
    t.string   "Accreditation_Date_Type"
    t.string   "Periods"
    t.string   "Last_Action"
    t.string   "school_domain_slice"
    t.datetime "created_at",                           null: false
    t.datetime "updated_at",                           null: false
    # number of all works belonging to all users who belong to the school
    t.integer  "works_count",              default: 0
    # number of all users at the school
    t.integer  "users_count",              default: 0, null: false
    # permalink url for the school; based on Instiuttion_Name
    t.string   "slug"
  end

  add_index "schools", ["slug"], name: "index_schools_on_slug", unique: true


#### I don't know about this. I must have tried to delete this table and it failed. 

# Could not dump table "schools_sans_internet" because of following NoMethodError
#   undefined method `[]' for nil:NilClass


  # Anybody (not just registered users) can suggest tags for works, which owners of the work can then approve or deny. 
  create_table "suggesteds", force: :cascade do |t|
    # If the user is a registered user, then this is populated. 
    t.integer  "user_id"
    t.integer  "work_id",                                  null: false
    # id of the user to whom the work belongs
    t.integer  "author_id",                                null: false
    # the suggested tag
    t.string   "suggestion",   limit: 128
    t.boolean  "approved",                 default: false, null: false
    # whether the suggestion has been either approved or denied by the owner
    t.boolean  "open",                     default: true,  null: false
    t.datetime "created_at",                               null: false
    t.datetime "updated_at",                               null: false
    # where the suggestion came from, for in case of abuse
    t.string   "suggester_ip"
  end

  add_index "suggesteds", ["work_id"], name: "index_suggesteds_on_work_id"

  # The following two tables created by gem 'acts-as-taggable-on' (https://github.com/mbleigh/acts-as-taggable-on)
  # This is a join [fact] table
  create_table "taggings", force: :cascade do |t|
    t.integer  "tag_id"
    t.integer  "taggable_id"
    t.string   "taggable_type"
    t.integer  "tagger_id"
    t.string   "tagger_type"
    t.string   "context",       limit: 128
    t.datetime "created_at"
  end

  add_index "taggings", ["tag_id", "taggable_id", "taggable_type", "context", "tagger_id", "tagger_type"], name: "taggings_idx", unique: true
  add_index "taggings", ["taggable_id", "taggable_type", "context"], name: "index_taggings_on_taggable_id_and_taggable_type_and_context"

  create_table "tags", force: :cascade do |t|
    t.string  "name"
    t.integer "taggings_count", default: 0
  end

  add_index "tags", ["name"], name: "index_tags_on_name", unique: true

  create_table "users", force: :cascade do |t|
    # users can choose and change their 'name', effectively a username. 
    # used to generate a slug. in case of duplicate name, a uuid is appended to make the slug unique
    t.string   "name"
    t.string   "email",                              null: false
    t.datetime "created_at",                         null: false
    t.datetime "updated_at",                         null: false
    # user's encrypted password
    t.string   "password_digest"
    # not set up at all to use this. maybe someday
    t.boolean  "admin",              default: false
    # encrypted string which is sent with user's activation email ("Please follow this link to acivate your account.") -- confirms the user actually owns the email provided
    t.string   "activation_digest"
    t.boolean  "activated",          default: false
    t.datetime "activated_at"
    # encrypted token for "remember me on this computer" cookie
    t.string   "remember_digest"
    t.integer  "school_id"
    # sets the default for the work they create to be either anonymouse or not. 
    t.boolean  "superman",           default: false, null: false
    # number of works they have added
    t.integer  "works_count",        default: 0,     null: false
    # number of works they have bookmarked
    t.integer  "bookmarks_count",    default: 0,     null: false
    # encrypted string for to reset password ("follow this link to reset your password")
    t.string   "reset_digest"
    # password reset token expires in 2 hours
    t.datetime "reset_sent_at"
    # based on name, then if neccessary appended with UUID for uniqueness
    t.string   "slug",                               null: false
    # These following five are managed entirely by the gem 'devise' (https://github.com/plataformatec/devise) and are fairly self-explanatory
    t.integer  "sign_in_count"
    t.datetime "current_sign_in_at"
    t.datetime "last_sign_in_at"
    t.string   "current_sign_in_ip"
    t.string   "last_sign_in_ip"
  end

  add_index "users", ["email"], name: "index_users_on_email", unique: true
  add_index "users", ["slug"], name: "index_users_on_slug", unique: true

  create_table "works", force: :cascade do |t|
    t.string   "name"
    # references the location of the (necessarily) uploaded file. this is not null: false because it can be a bitch faking uploads for R&D data like seeds. 
    t.string   "document"
    t.integer  "user_id",                              null: false
    t.datetime "created_at",                           null: false
    t.datetime "updated_at",                           null: false
    # inherits school association via user's concurrent school association
    t.integer  "school_id"
    # the kind of file that has been uploaded (ie. image/jpeg, text/plain, application/pdf, ...)
    t.string   "content_type"
    # in kilobytes
    t.integer  "file_size"
    # original name of the uploaded file
    t.string   "file_name"
    # average of all gradients for the work
    t.float    "gradient_average"
    # number of gradients for the the work
    t.integer  "gradient_count",       default: 0,     null: false
    # extracted content from text-based file (see document_uploader.rb for code)
    t.text     "file_content_md" # markdown
    t.text     "file_content_html" 
    # number of times the work has been bookmarked
    t.integer  "bookmarked_count",     default: 0,     null: false
    # rounded version of gradient_average to be compatible with RGB display
    t.integer  "gradient_average_rgb", default: 0,     null: false
    # toggles hiding/showing owner's actual name vs. Faker::Name.name (see work.rb for code)
    t.boolean  "anonymouse",           default: false, null: false
    # holds either fake name or real them (although currently real name does not update if user changes their name -- so we use work.user.name if !work.anonymouse)
    t.string   "author_name"
    t.string   "school_name"
    # plain text content extracted from text/ type files
    t.text     "file_content_text"
    t.string   "slug",                                 null: false
  end

  add_index "works", ["slug"], name: "index_works_on_slug", unique: true
  add_index "works", ["user_id", "created_at"], name: "index_works_on_user_id_and_created_at"
  add_index "works", ["user_id"], name: "index_works_on_user_id"

end
